# Build all container images.
#
# Most of the work is done in generic_build.bash, so see that file for details.

name: Build images
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  pull_request:
    paths-ignore:
    - '.circleci/**'
    - 'docs/**'
    - 'test/**'

env:
  BIOCONDA_UTILS_FOLDER: bioconda-utils
  DEBIAN_VERSION: "12.2"
  BUSYBOX_VERSION: "1.36.1"
  BASE_TAG: "0.1.4"  # "latest" will always be added during the build.
  BUILD_ENV_IMAGE_NAME: tmp-build-env
  CREATE_ENV_IMAGE_NAME: tmp-create-env
  BASE_DEBIAN_IMAGE_NAME: tmp-debian
  BASE_BUSYBOX_IMAGE_NAME: tmp-busybox
  ARCHS: "amd64 arm64"

jobs:

  build-base-debian:
    # NOTE: base-debian can be a separate job since it is independent of the
    # others. create-env depends on build-env, and both depend on base-busybox,
    # so we can't split that out.
    #
    # Later steps for other containers are similar, so comments are only added to
    # this first job.
    name: Build base-debian
    outputs:
      TAG_EXISTS_base-debian: ${{ steps.base-debian.outputs.TAG_EXISTS_base-debian }}
    runs-on: ubuntu-20.04
    steps:

    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    # Required for emulating ARM
    - name: Install qemu dependency
      run: |
        sudo apt-get update
        sudo apt-get install -y qemu-user-static

    - name: Build base-debian
      id: base-debian
      run: |
        # See generic_build.bash for expected env vars. The script will exit 64
        # if the tag exists. That's OK, and we don't want the entire Actions
        # workflow to fail because of it, so we check the exit code.
        IMAGE_NAME=$BASE_DEBIAN_IMAGE_NAME \
        IMAGE_DIR=images/base-glibc-debian-bash \
        TYPE="base-debian" \
        DEBIAN_VERSION=$DEBIAN_VERSION \
        ARCHS=$ARCHS \
        TAG=$BASE_TAG \
        ./generic_build.bash || [ $? == 64 ]

        # generic_build.bash will write key=val lines to the log ($TYPE.log);
        # these lines are added to $GITHUB_OUTPUT so that later steps can use
        # steps.id.outputs.key to get the value. See generic_build.bash for
        # what it's writing to the log (and therefore which keys are available
        # via the step's outputs).
        cat "base-debian.log" >> $GITHUB_OUTPUT

  build-others:
    # Other containers are interdependent, we so build them sequentially.
    # The steps are largely similar to base-debian above, so check there for
    # comments on common parts.
    name: Build base-busybox, build-env, and create-env images
    outputs:
      TAG_EXISTS_base-busybox: ${{ steps.base-busybox.outputs.TAG_EXISTS_base-busybox }}
      TAG_EXISTS_build-env: ${{ steps.build-env.outputs.TAG_EXISTS_build-env }}
      TAG_EXISTS_create-env: ${{ steps.create-env.outputs.TAG_EXISTS_create-env }}

    runs-on: ubuntu-20.04
    steps:

    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - id: get-tag
      # Get an appropriate tag to represent the version of bioconda-utils being
      # used, and make it available to other steps as outputs. This will be used
      # as BIOCONDA_UTILS_VERSION in later steps.
      run: |
        tag=${{ github.event.release && github.event.release.tag_name || github.head_ref || github.ref_name }}
        printf %s "tag=${tag#v}" >> $GITHUB_OUTPUT

    - name: Install qemu dependency
      run: |
        sudo apt-get update
        sudo apt-get install -y qemu-user-static

    - name: Build base-busybox
      id: base-busybox
      run: |
        IMAGE_NAME=$BASE_BUSYBOX_IMAGE_NAME \
        IMAGE_DIR=images/base-glibc-busybox-bash \
        TYPE="base-busybox" \
        ARCHS=$ARCHS \
        DEBIAN_VERSION=$DEBIAN_VERSION \
        BUSYBOX_VERSION=$BUSYBOX_VERSION \
        TAG=$BASE_TAG \
        ./generic_build.bash || [ $? == 64 ]
        cat "base-busybox.log" >> $GITHUB_OUTPUT

    - name: Build build-env
      id: build-env
      run: |
        # The build-env Dockerfile expects bioconda-utils to be cloned; even
        # though this CI is operating in the bioconda-utils repo, the code
        # needs to be available in the build context, which is in the
        # respective image dir.
        if [ ! -e "images/bioconda-utils-build-env-cos7/bioconda-utils" ]; then
          git clone https://github.com/bioconda/bioconda-utils images/bioconda-utils-build-env-cos7/bioconda-utils
        else
          (cd images/bioconda-utils-build-env-cos7/bioconda-utils && git fetch)
        fi

        # If the busybox image was not built in this CI run (e.g. if the
        # specified tags already exist on quay.io) then we'll get it from
        # quay.io. Otherwise use the just-built one.
        REGISTRY="localhost"
        if [ ${{ steps.base-busybox.outputs.TAG_EXISTS_base-busybox }} ]; then
          REGISTRY="quay.io/bioconda"
        fi

        BIOCONDA_UTILS_VERSION='${{ steps.get-tag.outputs.tag }}'

        IMAGE_NAME=$BUILD_ENV_IMAGE_NAME \
        IMAGE_DIR=images/bioconda-utils-build-env-cos7 \
        ARCHS=$ARCHS \
        TYPE="build-env" \
        BIOCONDA_UTILS_VERSION=$BIOCONDA_UTILS_VERSION \
        TAG="${BIOCONDA_UTILS_VERSION}-base${BASE_TAG}" \
        BUSYBOX_IMAGE="${REGISTRY}/${BASE_BUSYBOX_IMAGE_NAME}:${BASE_TAG}" \
        ./generic_build.bash || [ $? == 64 ]
        cat "build-env.log" >> $GITHUB_OUTPUT

    - name: Build create-env
      id: create-env
      run: |
        # Here we extract the conda and mamba versions from the just-created
        # build-env container (or, if it was not created in this CI run because
        # it already exists, then pull from quay.io). This ensures that when
        # creating environments, we use the exact same conda/mamba versions
        # that were used when building the package.
        BIOCONDA_UTILS_VERSION='${{ steps.get-tag.outputs.tag }}'
        REGISTRY="localhost"
        if [ ${{ steps.build-env.outputs.TAG_EXISTS_build-env }} ]; then
          REGISTRY="quay.io/bioconda"
        fi
        CONDA_VERSION=$(
                podman run -t "${REGISTRY}/${BUILD_ENV_IMAGE_NAME}:${BIOCONDA_UTILS_VERSION}-base${BASE_TAG}" \
                bash -c "/opt/conda/bin/conda list --export '^conda$'| sed -n 's/=[^=]*$//p'"
        )
        MAMBA_VERSION=$(
                podman run -t "${REGISTRY}/${BUILD_ENV_IMAGE_NAME}:${BIOCONDA_UTILS_VERSION}-base${BASE_TAG}" \
                bash -c "/opt/conda/bin/conda list --export '^mamba$'| sed -n 's/=[^=]*$//p'"
        )

        # Remove trailing \r with parameter expansion
        export CONDA_VERSION=${CONDA_VERSION%$'\r'}
        export MAMBA_VERSION=${MAMBA_VERSION%$'\r'}

        # See build-env for explanation
        REGISTRY="localhost"
        if [ ${{ steps.base-busybox.outputs.TAG_EXISTS_base-busybox }} ]; then
          REGISTRY="quay.io/bioconda"
        fi

        IMAGE_NAME=$CREATE_ENV_IMAGE_NAME \
        IMAGE_DIR=images/create-env \
        ARCHS=$ARCHS \
        TYPE="create-env" \
        BIOCONDA_UTILS_VERSION=$BIOCONDA_UTILS_VERSION \
        TAG="${BIOCONDA_UTILS_VERSION}-base${BASE_TAG}" \
        BUSYBOX_IMAGE="${REGISTRY}/${BASE_BUSYBOX_IMAGE_NAME}:${BASE_TAG}" \
        ./generic_build.bash || [ $? == 64 ]
        cat "create-env.log" >> $GITHUB_OUTPUT

  test:
    name: Test using images
    needs: [build-base-debian, build-others]
    runs-on: ubuntu-20.04
    steps:

    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    # Clone bioconda-recipes to use as part of the tests.
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
        repository: bioconda/bioconda-recipes
        path: /recipes

    - name: set path
      run: echo "/opt/mambaforge/bin" >> $GITHUB_PATH

    - name: Install bioconda-utils
      run: |
        export BIOCONDA_DISABLE_BUILD_PREP=1
        wget https://raw.githubusercontent.com/bioconda/bioconda-common/master/{common,install-and-set-up-conda,configure-conda}.sh
        bash install-and-set-up-conda.sh
        eval "$(conda shell.bash hook)"
        mamba create -n bioconda -y --file test-requirements.txt --file bioconda_utils/bioconda_utils-requirements.txt
        conda activate bioconda
        python setup.py install

    - name: test
      run: |
        # Decide, for each image, whether it was just built as part of this run
        # (in which case we use localhost) or otherwise pull from quay.io.
        if [ ${{ needs.build-others.outputs.TAG_EXISTS_base-busybox }} ]; then
          DEST_BASE_IMAGE_REGISTRY='quay.io/bioconda'
        else
          DEST_BASE_IMAGE_REGISTRY=localhost
        fi

        if [ ${{ needs.build-others.outputs.TAG_EXISTS_build-env }} ]; then
          BUILD_ENV_REGISTRY='quay.io/bioconda'
        else
          BUILD_ENV_REGISTRY=localhost
        fi

        if [ ${{ needs-build-others.outputs.TAG_EXISTS_create-env }} ]; then
          BUILD_ENV_REGISTRY='quay.io/bioconda'
        else
          BUILD_ENV_REGISTRY=localhost
        fi

        BIOCONDA_UTILS_VERSION='${{ steps.get-tag.outputs.tag }}'

        cd /recipes

        # Run a test build, specifying the exact images to use.
        DEST_BASE_IMAGE="${DEST_BASE_IMAGE_REGISTRY}/${BASE_BUSYBOX_IMAGE_NAME}:${BASE_TAG}" \
        bioconda-utils build \
        --docker-base-image "${BUILD_ENV_REGISTRY}/${BUILD_ENV_IMAGE_NAME}:${BIOCONDA_UTILS_VERSION}-base${BASE_TAG}" \
        --mulled-conda-image "${CREATE_ENV_REGISTRY}/${CREATE_ENV_IMAGE_NAME}:${BIOCONDA_UTILS_VERSION}-base${BASE_TAG}" \
        --packages seqtk \
        --docker \
        --mulled-test \
        --force

  push:
    needs: [build-base-debian, build-others, test]
    runs-on: ubuntu-20.04
    # For these push steps, a repository must first exist on quay.io/bioconda
    # AND that repository must also be configured to allow write access for the
    # appropriate service account. This must be done by a user with admin
    # access to quay.io/bioconda.
    #
    # generic_build.bash reported whether the tag exists to the log; that was
    # added to GITHUB_OUTPUT, those outputs are exposed to the jobs, and
    # those jobs are dependencies of this job. So now we can use those
    # outputs to determine if we should upload.
    steps:

    - name: Push base-debian
      id: push-base-debian
      uses: redhat-actions/push-to-registry@v2
      if: ${{ ! needs.build-base-debian.outputs.TAG_EXISTS_base-debian }}
      with:
        image: ${{ env.BASE_DEBIAN_IMAGE_NAME }}
        tags: latest ${{ env.BASE_TAG }}
        registry: quay.io/bioconda
        username: ${{ secrets.QUAY_BIOCONDA_USERNAME }}
        password: ${{ secrets.QUAY_BIOCONDA_TOKEN }}

    - name: Push base-busybox
      id: push-base-busybox
      uses: redhat-actions/push-to-registry@v2
      if: ${{ ! needs.build-others.outputs.TAG_EXISTS_base-busybox }}
      with:
        image: ${{ env.BASE_BUSYBOX_IMAGE_NAME }}
        tags: latest ${{ env.BASE_TAG }}
        registry: quay.io/bioconda
        username: ${{ secrets.QUAY_BIOCONDA_USERNAME }}
        password: ${{ secrets.QUAY_BIOCONDA_TOKEN }}

    - name: Push build-env
      id: push-build-env
      uses: redhat-actions/push-to-registry@v2
      if: ${{ ! needs.build-others.outputs.TAG_EXISTS_build-env }}
      with:
        image: ${{ env.BUILD_ENV_IMAGE_NAME }}
        tags: latest ${{ steps.get-tag.outputs.tag }}-base${{ env.BASE_TAG }}
        registry: quay.io/bioconda
        username: ${{ secrets.QUAY_BIOCONDA_USERNAME }}
        password: ${{ secrets.QUAY_BIOCONDA_TOKEN }}

    - name: Push create-env
      id: push-create-env
      uses: redhat-actions/push-to-registry@v2
      if: ${{ ! needs.build-others.outputs.TAG_EXISTS_create-env }}
      with:
        image: ${{ env.CREATE_ENV_IMAGE_NAME }}
        tags: latest ${{ steps.get-tag.outputs.tag }}-base${{ env.BASE_TAG }}
        registry: quay.io/bioconda
        username: ${{ secrets.QUAY_BIOCONDA_USERNAME }}
        password: ${{ secrets.QUAY_BIOCONDA_TOKEN }}
